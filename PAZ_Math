#ifndef PAZ_MATH
#define PAZ_MATH

#include <iostream>
#include <cmath>
#include <vector>

#ifndef M_E
#define M_E        2.71828182845904523536028747135      /* e */
#endif
#ifndef M_LOG2E
#define M_LOG2E    1.44269504088896340735992468100      /* log_2 (e) */
#endif
#ifndef M_LOG10E
#define M_LOG10E   0.43429448190325182765112891892      /* log_10 (e) */
#endif
#ifndef M_SQRT2
#define M_SQRT2    1.41421356237309504880168872421      /* sqrt(2) */
#endif
#ifndef M_SQRT1_2
#define M_SQRT1_2  0.70710678118654752440084436210      /* sqrt(1/2) */
#endif
#ifndef M_SQRT3
#define M_SQRT3    1.73205080756887729352744634151      /* sqrt(3) */
#endif
#ifndef M_PI
#define M_PI       3.14159265358979323846264338328      /* pi */
#endif
#ifndef M_PI_2
#define M_PI_2     1.57079632679489661923132169164      /* pi/2 */
#endif
#ifndef M_PI_4
#define M_PI_4     0.78539816339744830961566084582     /* pi/4 */
#endif
#ifndef M_SQRTPI
#define M_SQRTPI   1.77245385090551602729816748334      /* sqrt(pi) */
#endif
#ifndef M_2_SQRTPI
#define M_2_SQRTPI 1.12837916709551257389615890312      /* 2/sqrt(pi) */
#endif
#ifndef M_1_PI
#define M_1_PI     0.31830988618379067153776752675      /* 1/pi */
#endif
#ifndef M_2_PI
#define M_2_PI     0.63661977236758134307553505349      /* 2/pi */
#endif
#ifndef M_LN10
#define M_LN10     2.30258509299404568401799145468      /* ln(10) */
#endif
#ifndef M_LN2
#define M_LN2      0.69314718055994530941723212146      /* ln(2) */
#endif
#ifndef M_LNPI
#define M_LNPI     1.14472988584940017414342735135      /* ln(pi) */
#endif
#ifndef M_EULER
#define M_EULER    0.57721566490153286060651209008      /* Euler constant */
#endif

namespace paz
{
    double randn();
    int randi(int a, int b);
    double uniform();
    double uniform(double a, double b);

    inline double fract(const double n)
    {
        return n - std::floor(n);
    }

    inline double normalize_angle(const double n)
    {
        return fract(n/(2.*M_PI))*2.*M_PI;
    }

    class Vec;
    class Mat
    {
        std::vector<double> _vals;
        std::size_t _rows = 0;

    public:
        static Mat Constant(std::size_t rows, std::size_t cols, double c);
        static Mat Constant(std::size_t side, double c);
        static Mat Zero(std::size_t rows, std::size_t cols);
        static Mat Zero(std::size_t side);
        static Mat Ones(std::size_t rows, std::size_t cols);
        static Mat Ones(std::size_t side);
        static Mat Identity(std::size_t side);

        Mat() = default;
        Mat(std::size_t rows, std::size_t cols);
        Mat(std::size_t side);
        Mat(const Vec& v);
        Mat(const std::initializer_list<std::initializer_list<double>>& list);

        Mat inv() const;
        Mat solve(const Mat& b) const; // x : (*this)*x = b
        Mat chol() const;
        Mat cholUpdate(const Mat& m, double a) const;
        Mat trans() const;
        double& operator()(std::size_t i, std::size_t j);
        double operator()(std::size_t i, std::size_t j) const;
        double& operator()(std::size_t i);
        double operator()(std::size_t i) const;
        std::size_t size() const;
        std::size_t rows() const;
        std::size_t cols() const;
        double* data();
        const double* data() const;
        bool empty() const;
        auto begin()
        {
            return _vals.begin();
        }
        auto begin() const
        {
            return _vals.begin();
        }
        auto end()
        {
            return _vals.end();
        }
        auto end() const
        {
            return _vals.end();
        }
        double normSq() const;
        double norm() const;
        Mat normalized() const;
        Mat& operator*=(const Mat& rhs);
        Mat operator*(const Mat& rhs) const;
        Mat& operator+=(const Mat& rhs);
        Mat operator+(const Mat& rhs) const;
        Mat& operator-=(const Mat& rhs);
        Mat operator-(const Mat& rhs) const;
        Mat& operator*=(double rhs);
        Mat operator*(double rhs) const;
        Mat& operator/=(double rhs);
        Mat operator/(double rhs) const;
        Mat operator-() const;
        double dot(const Mat& rhs) const;
        Mat block(std::size_t startRow, std::size_t startCol, std::size_t
            numRows, std::size_t numCols) const;
        void setBlock(std::size_t startRow, std::size_t startCol, std::size_t
            numRows, std::size_t numCols, const Mat& rhs);
        Mat row(std::size_t m) const;
        void setRow(std::size_t m, const Mat& rhs);
        Mat col(std::size_t n) const;
        void setCol(std::size_t n, const Mat& rhs);
    };

    Mat& operator*=(double lhs, Mat& rhs);
    Mat operator*(double lhs, const Mat& rhs);

    std::ostream& operator<<(std::ostream& out, const paz::Mat& x);

    class Vec : public Mat
    {
    public:
        static Vec Constant(std::size_t rows, double c);
        static Vec Zero(std::size_t rows);
        static Vec Ones(std::size_t rows);
        static Vec IdQuat();

        Vec() = default;
        Vec(std::size_t rows);
        Vec(const Mat& m);
        Vec(const std::initializer_list<std::initializer_list<double>>& list);

        Vec segment(std::size_t start, std::size_t n) const;
        void setSegment(std::size_t start, std::size_t n, const Vec& rhs) const;
        Vec head(std::size_t n) const;
        void head(std::size_t n, const Vec& rhs) const;
        Vec tail(std::size_t n) const;
        void tail(std::size_t n, const Vec& rhs) const;
        Vec cross(const Vec& rhs) const;
    };

    Mat to_mat(const Vec& q);
    Vec to_quat(const Mat& m);
    Vec qinv(const Vec& q);
    Mat xi(const Vec& q);
    Vec qmult(const Vec& p, const Vec& q);
    Vec axis_angle(const Vec& axis, double angle);
}

#endif
